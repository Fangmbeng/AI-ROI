# app/agents/optimization_recommendation_agent.py
import datetime
from typing import List
from vertexai.preview.reasoning_engines import ReasoningEngine, LangchainAgent
from app.models.optimization_recommendation import OptimizationRecommendation
from app.services.bigquery_service import BigQueryService
from app.services.vertex_ai_service import VertexAIService
from app.utils.config import PlatformConfig
from google.adk.agents import LlmAgent


class OptimizationRecommendationAgent(LlmAgent):
    def __init__(
        self,
        config: PlatformConfig,
        bq_service: BigQueryService,
        vertex_service: VertexAIService
    ):
        self.__bq = bq_service
        self.__vertex = vertex_service
        self.__config = config

        super().__init__(
            name="optimization_recommendation_agent",
            model="gemini-2.0-flash",
            description="Generates and persists infrastructure optimization recommendations",
            tools=[self.recommend_optimizations],
        )
    @property
    def bq(self):
        return self.__bq

    @property
    def vertex(self):
        return self.__vertex

    @property
    def config(self):
        return self.__config

    def recommend_optimizations(self) -> List[OptimizationRecommendation]:
        # 1) Fetch latest correlation insights
        corr_rows = self.bq.client.query(
            f"\"SELECT * FROM `{self.bq.project_id}.{self.bq.dataset_id}.roi_correlations` ORDER BY timestamp DESC LIMIT 10\"" #### Inspect for later
        ).to_dataframe().to_dict(orient="records")

        # 2) Call Vertex AI to get recommendations
        current_state = self.vertex.get_current_infrastructure_state()
        recs = self.vertex.generate_optimization_recommendations(
            current_state,
            context="Recent ROI correlations",
            budget_constraint=None,
            performance_target=None
        )

        # 3) Enhance each rec with impact and risk, then persist
        enriched = []
        rows = []
        for rec in recs:
            impact = self.vertex.calculate_recommendation_impact([rec], current_state)[0]
            risk = self.vertex.assess_implementation_risk([rec])[0]
            opt = OptimizationRecommendation(
                workload=rec["component"],
                model_id="N/A",
                action=rec["action"],
                # expected_impact=f"\"${impact['expected_savings_usd']:.2f}\"," #### Inspect for later
                rationale=risk["risk"]
            )
            enriched.append(opt)
            rows.append({
                "timestamp": datetime.utcnow().isoformat(),
                "workload": opt.workload,
                "model_id": opt.model_id,
                "action": opt.action,
                "expected_impact": impact["expected_savings_usd"],
                "rationale": rec.get("details", ""),
            })
        self.bq.insert_rows("optimization_recommendations", rows)
        return enriched
